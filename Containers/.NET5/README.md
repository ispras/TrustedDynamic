# Уровни проверки интерпретатора

1) Сам компилятор на предмет генерации неверного байт-кода (для C# IL).
2) Интерпертатор байт-кода MSIL, встроенный в среду выполнения.
3) Перерасход ресурсов, доступ к данным "за песочницей", креш машины (Если попробовать рассмотреть, как виртуальную машину по типу Java- или JS-машины, окажется, что интересные кейсы по выходу из нее)
4) Следующим уровнем абстракции можно считать базовые типы Common Type System (CTS). Тут уже открывается некий простор (уже можно искать наработки в интернете)
5) Далее - проверка основных библиотечных классов работы с данными из состава Net Core SDK. Тут можно обнаружить уже парсеры XML, json, файлов конфигурации.
6) Инфраструктурные классы из состава SDK - реализующие внешние сетевые интерфейсы.

# Сборка подсистемы coreclr из состава .NET5.

Устанавливается компилятор clang-12, выполняется сборка AFLplusplus (протестировано на 3.12c), подменяются компиляторы для сборки собственно coreclr на -lto -компиляторы из состава AFL++, выполняется сборка coreclr с формированием слования лексем на этапе компиляции (AUTODICTIONARY из состава последнийх AFL++ - для самопроверки, что всё работает)

``` bash
docker build --build-arg cuid=$(id -u) --build-arg cgid=$(id -g) --build-arg cuidname=$(id -un) --build-arg cgidname=$(id -gn) -t net5_coreclr -f Dockerfile_net5_coreclr.txt .
```

# Команда запуска контейнера

``` bash
docker run -it --name=net5 net5_coreclr
```

# Команда тестового запуска фаззинга инструментированного бинарника дизассемблера (всё должно завестить, будут находится разумные сэмплы (MZ в начале))

``` bash
mkdir -p test/in && echo 111 > test/in/sam && ../AFLplusplus/afl-fuzz -i test/in -o out -x clr.dict -- artifacts/bin/coreclr/Linux.x64.Debug/ildasm @@
```